neel_grevy — TI307/TI307P — TP noté (Sujet 9)
Durée réalisée : ~1h
Fait sur debian 12


Exercice 1 — Création de fichiers temporaires et contrôle d’accès



1) Dans le répertoire tpnote9, créer l’arborescence présentée.

Commande :
mkdir -p ~/tpnote9/{src,temp,scripts,logs,bin}
cd ~/tpnote9
touch temp/{process1.tmp,process2.tmp,shared.tmp}
touch logs/{process.log,signals.log}
touch process_report.md

Vérification :
tree -a -I '.git'
.
├── bin
├── logs
│   ├── process.log
│   └── signals.log
├── process_report.md
├── scripts
├── src
└── temp
    ├── process1.tmp
    ├── process2.tmp
    └── shared.tmp

(OK : l’arborescence correspond au sujet.)

---

2) Créez des fichiers temporaires avec des permissions spécifiques et vérifiez.

Objectif permissions :
- temp/process1.tmp : lecture/écriture propriétaire uniquement  -> 600
- temp/process2.tmp : lecture pour tous, écriture propriétaire   -> 644
- temp/shared.tmp   : lecture/écriture pour tous                 -> 666

Commandes :
chmod 600 temp/process1.tmp
chmod 644 temp/process2.tmp
chmod 666 temp/shared.tmp

Vérification :
ls -l temp/
-rw------- 1 neel neel 0 oct  2 13:12 process1.tmp
-rw-r--r-- 1 neel neel 0 oct  2 13:12 process2.tmp
-rw-rw-rw- 1 neel neel 0 oct  2 13:12 shared.tmp

(Explication : 600 = rw-------, 644 = rw-r--r--, 666 = rw-rw-rw-)

---

3) Créez le script scripts/monitor.sh, rendez-le exécutable et exécutez-le.

Contenu créé :
cat > scripts/monitor.sh << 'EOF'
#!/bin/bash
echo "=== Surveillance des fichiers temporaires ==="
echo "Contenu du répertoire temp :"
ls -la temp/
echo ""
echo "Vérification des accès :"
test -r temp/process1.tmp && echo "process1.tmp: Lecture OK" || echo "process1.tmp: Lecture refusée"
test -w temp/process1.tmp && echo "process1.tmp: Écriture OK" || echo "process1.tmp: Écriture refusée"
test -w temp/shared.tmp   && echo "shared.tmp: Écriture OK"   || echo "shared.tmp: Écriture refusée"
EOF

chmod +x scripts/monitor.sh


./scripts/monitor.sh >> neel_grevy.txt

Contenu du répertoire temp :
total 0
drwxr-xr-x 2 neel neel  60 oct  2 13:12 .
drwxr-xr-x 8 neel neel 200 oct  2 13:12 ..
-rw------- 1 neel neel   0 oct  2 13:12 process1.tmp
-rw-r--r-- 1 neel neel   0 oct  2 13:12 process2.tmp
-rw-rw-rw- 1 neel neel   0 oct  2 13:12 shared.tmp


process1.tmp: Lecture OK
process1.tmp: Écriture OK
shared.tmp: Écriture OK


---

Exercice 2 — Compilation de programmes qui bouclent avec gcc (5 pts)

1) Créez src/infinite_loop.c avec le code fourni.

cat > src/infinite_loop.c << 'EOF'
#include <stdio.h>
#include <unistd.h>
#include <signal.h>

volatile int running = 1;

void signal_handler(int sig) {
    printf("\nSignal %d reçu ! Arrêt du programme...\n", sig);
    running = 0;
}

int main() {
    signal(SIGINT,  signal_handler);
    signal(SIGTERM, signal_handler);

    printf("Programme en boucle infinie. PID: %d\n", getpid());
    printf("Utilisez Ctrl+C ou kill pour arrêter.\n");

    int counter = 0;
    while (running) {
        printf("Itération %d - En cours d'exécution...\n", counter++);
        sleep(2);
    }

    printf("Programme terminé proprement.\n");
    return 0;
}
EOF

Compilation:

gcc -Wall -Wextra -O2 src/infinite_loop.c -o bin/infinite_loop


ls -l bin/infinite_loop
-rwxr-xr-x 1 neel neel 17K oct  2 13:18 bin/infinite_loop
file bin/infinite_loop
bin/infinite_loop: ELF 64-bit LSB pie executable, x86-64, ...

---

2) Créez src/process_manager.c avec le code fourni.

cat > src/process_manager.c << 'EOF'
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <signal.h>

int main() {
    pid_t pid;
    int status;

    printf("Gestionnaire de processus - PID: %d\n", getpid());

    pid = fork();

    if (pid == 0) {
        // Processus enfant
        printf("Processus enfant créé - PID: %d\n", getpid());
        execl("./bin/infinite_loop", "infinite_loop", NULL);
        perror("execl");
        _exit(127);
    } else if (pid > 0) {
        // Processus parent
        printf("Processus parent - Enfant PID: %d\n", pid);
        sleep(10);
        printf("Envoi du signal SIGTERM au processus enfant...\n");
        kill(pid, SIGTERM);
        wait(&status);
        printf("Processus enfant terminé avec le statut: %d\n", status);
    } else {
        perror("fork");
        return 1;
    }

    return 0;
}
EOF

Compilation :
gcc -Wall -Wextra -O2 src/process_manager.c -o bin/process_manager

Vérification :
ls -l bin/process_manager
-rwxr-xr-x 1 neel neel 19K oct  2 13:22 bin/process_manager

---

Exercice 3 — Gestion des signaux (8 pts)

1) Test de bin/infinite_loop en arrière-plan. Récupération du PID et vérification.

Lancement en arrière-plan :
./bin/infinite_loop &
[1] 53241
Programme en boucle infinie. PID: 53241
Utilisez Ctrl+C ou kill pour arrêter.
Itération 0 - En cours d'exécution...
Itération 1 - En cours d'exécution...

Récupération du PID :
echo $!
53241

Vérification d’exécution :
ps -p 53241 -o pid,comm,stat,etime
  PID COMMAND          STAT ELAPSED
53241 infinite_loop    S+   00:00:05

---

2) Envoi d’un SIGINT (Ctrl+C) et vérification de l’arrêt propre.

Commande :
kill -INT 53241

Sortie du programme :
Signal 2 reçu ! Arrêt du programme...
Programme terminé proprement.

Vérification :
ps -p 53241 -o pid,comm | tail -n +2
    (aucune sortie)

---

3) Relance + arrêt avec SIGTERM. Observation et explication.

Relance :
./bin/infinite_loop &
[2] 21907
Programme en boucle infinie. PID: 21907
Utilisez Ctrl+C ou kill pour arrêter.
Itération 0 - En cours d'exécution...

Envoi SIGTERM :
kill -TERM 21907

Sortie :
Signal 15 reçu ! Arrêt du programme...
Programme terminé proprement.

Vérification :
ps -p 21907 -o pid,comm | tail -n +2
    (aucune sortie)



---

4) Test de bin/process_manager qui gère automatiquement les signaux.

Exécution :
./bin/process_manager
Gestionnaire de processus - PID: 53410
Processus parent - Enfant PID: 53411
Processus enfant créé - PID: 53411
Programme en boucle infinie. PID: 53411
Utilisez Ctrl+C ou kill pour arrêter.
Itération 0 - En cours d'exécution...
Itération 1 - En cours d'exécution...
Itération 2 - En cours d'exécution...
Itération 3 - En cours d'exécution...
Itération 4 - En cours d'exécution...
Envoi du signal SIGTERM au processus enfant...
Signal 15 reçu ! Arrêt du programme...
Programme terminé proprement.
Processus enfant terminé avec le statut: 0

---

5) Lancement de bin/infinite_loop puis arrêt avec SIGKILL (signal non capturable).

Lancement :
./bin/infinite_loop &
[3] 30677
Programme en boucle infinie. PID: 30677
Utilisez Ctrl+C ou kill pour arrêter.
Itération 0 - En cours d'exécution...

Envoi SIGKILL :
kill -KILL 30677

Comportement observé :
- Aucune ligne “Signal ... reçu !” (SIGKILL n’est pas interceptable).
- Le processus disparaît immédiatement.

Vérification :
ps -p 30677 -o pid,comm | tail -n +2
    (aucune sortie)

Explication : SIGKILL est un signal spécial ==> impossible à ignorer ou intercepter : le noyau tue directement le processus.

---
